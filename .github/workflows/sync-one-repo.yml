name: Sync Labels (single repo)

on:
  workflow_dispatch:
    inputs:
      repo:
        description: "Dépôt cible"
        required: true
        type: choice
        options:
          # BEGIN_REPO_OPTIONS (auto-updated)
          - pulse-web-interface
          - pulse-app-pilotage
          - pulse-mdm-android-service
          - Graffwall_V3
          - pulse-mdm-server
          # END_REPO_OPTIONS
      delete-extraneous:
        description: "Supprimer les labels non listés dans labels.yml ?"
        required: false
        default: "false"
        type: choice
        options: ["false", "true"]

permissions:
  contents: read

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout .github repo
        uses: actions/checkout@v4

      - name: Check gh CLI
        run: gh --version

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install yaml parser
        run: npm install js-yaml@4

      - name: Run per-repo sync
        env:
          GH_TOKEN: ${{ secrets.ORG_LABELS_TOKEN }} # PAT org: Issues RW + Metadata Read
          ORG: ${{ github.repository_owner }}
          REPO: ${{ github.event.inputs.repo }}
          DELETE_EXTRA: ${{ github.event.inputs.delete-extraneous }}
        run: |
          node - <<'EOF'
          const fs = require('fs');
          const yaml = require('js-yaml');
          const { execFileSync } = require('child_process');

          const token = process.env.GH_TOKEN;
          const org = process.env.ORG;
          const repo = process.env.REPO;
          const deleteExtra = (process.env.DELETE_EXTRA || 'false') === 'true';

          if (!token) { console.error('Missing ORG_LABELS_TOKEN.'); process.exit(1); }
          if (!org || !repo) { console.error('Missing ORG or REPO.'); process.exit(1); }

          const env = { ...process.env, GH_TOKEN: token };
          const H = ['api', '-H', 'Accept: application/vnd.github+json'];

          function ghGET(path) {
            const out = execFileSync('gh', [...H, path], { env, stdio: ['ignore','pipe','inherit'], encoding: 'utf8' });
            return JSON.parse(out);
          }
          function ghPOST(path, formKVs) {
            execFileSync('gh', [...H, path, '-X', 'POST', ...formKVs], { env, stdio: ['ignore','pipe','inherit'] });
          }
          function ghPATCH(path, formKVs) {
            execFileSync('gh', [...H, path, '-X', 'PATCH', ...formKVs], { env, stdio: ['ignore','pipe','inherit'] });
          }
          function ghDELETE(path) {
            execFileSync('gh', [...H, path, '-X', 'DELETE'], { env, stdio: ['ignore','pipe','inherit'] });
          }

          // Helpers de normalisation
          const str = v => (v ?? '').toString();
          const normHex = c => str(c).replace(/^#/, '').trim().toLowerCase();
          const isHex6 = c => /^[0-9a-f]{6}$/.test(c);

          console.log(`Target: ${org}/${repo}`);

          // Charger labels.yml
          const labelsPath = '.github/labels.yml';
          const labels = yaml.load(fs.readFileSync(labelsPath, 'utf8')) || [];
          if (!Array.isArray(labels) || labels.length === 0) {
            console.error('labels.yml is empty or invalid.');
            process.exit(1);
          }
          const canonical = new Map();
          const orderedLabels = [];
          for (const raw of labels) {
            const labelName = raw?.name;
            if (!labelName) {
              console.warn('  ! skipped label without a name entry');
              continue;
            }
            if (canonical.has(labelName)) {
              console.warn(`  ! duplicate label entry skipped: ${labelName}`);
              continue;
            }
            canonical.set(labelName, raw);
            orderedLabels.push(raw);
          }
          if (orderedLabels.length === 0) {
            console.error('labels.yml has no usable entries.');
            process.exit(1);
          }

          // Récupérer labels existants (pagination)
          let existing = [], page = 1;
          while (true) {
            const res = ghGET(`repos/${org}/${repo}/labels?per_page=100&page=${page}`);
            if (!res.length) break;
            existing = existing.concat(res);
            page++;
          }
          const existingMap = new Map(existing.map(l => [l.name, l]));

          // Créer / mettre à jour
          for (const L of orderedLabels) {
            const ex = existingMap.get(L.name);
            const newColor = normHex(L.color);
            const newDesc  = str(L.description);
            if (!isHex6(newColor)) {
              console.warn(`  ! skipped invalid color for ${L.name}: "${L.color}"`);
            }

            if (!ex) {
              try {
                const form = ['-f', `name=${L.name}`];
                form.push('-f', `color=${isHex6(newColor) ? newColor : 'cccccc'}`);
                form.push('-f', `description=${newDesc}`);
                ghPOST(`repos/${org}/${repo}/labels`, form);
                console.log(`  + created: ${L.name}`);
              } catch (e) {
                console.error(`  ! create failed: ${L.name} (${e.message})`);
              }
              continue;
            }

            const oldColor = normHex(ex.color);
            const oldDesc  = str(ex.description);

            const needsUpdate =
              (isHex6(newColor) && oldColor !== newColor) ||
              (oldDesc !== newDesc);

            if (needsUpdate) {
              try {
                const encoded = encodeURIComponent(ex.name);
                const form = ['-f', `new_name=${L.name}`];
                if (isHex6(newColor)) form.push('-f', `color=${newColor}`);
                form.push('-f', `description=${newDesc}`);
                ghPATCH(`repos/${org}/${repo}/labels/${encoded}`, form);
                console.log(`  ~ updated: ${L.name}`);
              } catch (e) {
                console.error(`  ! update failed: ${L.name} (${e.message})`);
              }
            } else {
              console.log(`  = up-to-date: ${L.name}`);
            }
          }

          // Supprimer les labels non listés (optionnel)
          if (deleteExtra) {
            for (const exName of existingMap.keys()) {
              if (!canonical.has(exName)) {
                try {
                  const encoded = encodeURIComponent(exName);
                  ghDELETE(`repos/${org}/${repo}/labels/${encoded}`);
                  console.log(`  - deleted: ${exName}`);
                } catch (e) {
                  console.error(`  ! delete failed: ${exName} (${e.message})`);
                }
              }
            }
          }
          EOF
