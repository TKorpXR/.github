name: Sync Labels (single repo)

on:
  workflow_dispatch:
    inputs:
      repo:
        description: "Dépôt cible"
        required: true
        type: choice
        options:
          # BEGIN_REPO_OPTIONS (auto-updated)
          - pulse-web-interface
          - pulse-app-pilotage
          - pulse-mdm-android-service
          - Graffwall_V3
          - pulse-mdm-server
          # END_REPO_OPTIONS
      delete-extraneous:
        description: "Supprimer les labels non listés dans labels.yml ?"
        required: false
        default: "false"
        type: choice
        options: ["false", "true"]

permissions:
  contents: read

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout .github repo
        uses: actions/checkout@v4

      - name: Check gh CLI
        run: gh --version

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install yaml parser
        run: npm install js-yaml@4

      - name: Run per-repo sync
        env:
          GH_TOKEN: ${{ secrets.ORG_LABELS_TOKEN }} # PAT org: Issues RW + Metadata Read
          ORG: ${{ github.repository_owner }}
          REPO: ${{ github.event.inputs.repo }}
          DELETE_EXTRA: ${{ github.event.inputs.delete-extraneous }}
        run: |
          node - <<'EOF'
          const fs = require('fs');
          const yaml = require('js-yaml');
          const { execFileSync } = require('child_process');

          const token = process.env.GH_TOKEN;
          const org = process.env.ORG;
          const repo = process.env.REPO;
          const deleteExtra = (process.env.DELETE_EXTRA || 'false') === 'true';

          if (!token) { console.error('Missing ORG_LABELS_TOKEN.'); process.exit(1); }
          if (!org || !repo) { console.error('Missing ORG or REPO.'); process.exit(1); }

          const env = { ...process.env, GH_TOKEN: token };
          const H = ['api', '-H', 'Accept: application/vnd.github+json'];

          function ghGET(path) {
            const out = execFileSync('gh', [...H, path], { env, stdio: ['ignore','pipe','inherit'], encoding: 'utf8' });
            return JSON.parse(out);
          }
          function ghPOST(path, formKVs) {
            execFileSync('gh', [...H, path, '-X', 'POST', ...formKVs], { env, stdio: ['ignore','pipe','inherit'] });
          }
          function ghPATCH(path, formKVs) {
            execFileSync('gh', [...H, path, '-X', 'PATCH', ...formKVs], { env, stdio: ['ignore','pipe','inherit'] });
          }
          function ghDELETE(path) {
            execFileSync('gh', [...H, path, '-X', 'DELETE'], { env, stdio: ['ignore','pipe','inherit'] });
          }

          console.log(`Target: ${org}/${repo}`);

          // Charger labels.yml
          const labelsPath = '.github/labels.yml';
          const labels = yaml.load(fs.readFileSync(labelsPath, 'utf8')) || [];
          if (!Array.isArray(labels) || labels.length === 0) {
            console.error('labels.yml is empty or invalid.');
            process.exit(1);
          }
          const canonical = new Map(labels.map(l => [l.name, l]));

          // Récupérer labels existants (pagination)
          let existing = [], page = 1;
          while (true) {
            const res = ghGET(`repos/${org}/${repo}/labels?per_page=100&page=${page}`);
            if (!res.length) break;
            existing = existing.concat(res);
            page++;
          }
          const existingMap = new Map(existing.map(l => [l.name, l]));

          // Créer / mettre à jour
          for (const L of labels) {
            const ex = existingMap.get(L.name);
            if (!ex) {
              try {
                ghPOST(`repos/${org}/${repo}/labels`, [
                  '-f', `name=${L.name}`,
                  '-f', `color=${L.color}`,
                  '-f', `description=${L.description || ''}`
                ]);
                console.log(`  + created: ${L.name}`);
              } catch (e) {
                console.error(`  ! create failed: ${L.name} (${e.message})`);
              }
            } else {
              const needsUpdate =
                (L.color && ex.color?.toLowerCase() !== L.color.toLowerCase()) ||
                ((L.description || '') !== (ex.description || ''));
              if (needsUpdate) {
                try {
                  const encoded = encodeURIComponent(ex.name);
                  ghPATCH(`repos/${org}/${repo}/labels/${encoded}`, [
                    '-f', `new_name=${L.name}`,
                    '-f', `color=${L.color}`,
                    '-f', `description=${L.description || ''}`
                  ]);
                  console.log(`  ~ updated: ${L.name}`);
                } catch (e) {
                  console.error(`  ! update failed: ${L.name} (${e.message})`);
                }
              } else {
                console.log(`  = up-to-date: ${L.name}`);
              }
            }
          }

          // Supprimer les labels non listés (optionnel)
          if (deleteExtra) {
            for (const exName of existingMap.keys()) {
              if (!canonical.has(exName)) {
                try {
                  const encoded = encodeURIComponent(exName);
                  ghDELETE(`repos/${org}/${repo}/labels/${encoded}`);
                  console.log(`  - deleted: ${exName}`);
                } catch (e) {
                  console.error(`  ! delete failed: ${exName} (${e.message})`);
                }
              }
            }
          }
          EOF
